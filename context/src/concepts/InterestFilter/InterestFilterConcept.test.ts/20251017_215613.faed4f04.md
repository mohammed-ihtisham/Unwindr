---
timestamp: 'Fri Oct 17 2025 21:56:13 GMT-0400 (Eastern Daylight Time)'
content_id: faed4f04e83b63b1bb417a38e66390b18a61640aa48702e4c72804ce2d558e5c
---

# file: src/concepts/InterestFilter/InterestFilterConcept.test.ts

```typescript
import { assertEquals, assertExists, assertNotEquals } from "jsr:@std/assert";
import { testDb } from "@utils/database.ts";
import { Empty, ID } from "@utils/types.ts";
import InterestFilterConcept from "./InterestFilterConcept.ts";

// Helper for checking if a result is an error
const isError = (result: any): result is { error: string } =>
  result && typeof result === "object" && "error" in result;

// Mock User and Place IDs for testing
const USER_ALICE = "user:Alice" as ID;
const USER_BOB = "user:Bob" as ID;
const USER_CHARLIE = "user:Charlie" as ID;

const PLACE_PARK = "place:Larchmont_Manor_Park" as ID;
const PLACE_CAFE = "place:Maplewood_Reading_Garden" as ID;
const PLACE_BAR = "place:Riverside_Jazz_Nights" as ID;
const PLACE_HISTORIC = "place:Old_Mill_Stone_Bridge" as ID;
const PLACE_BOARDWALK = "place:Harbor_Lights_Boardwalk" as ID;

// Mock places array to be passed to getMatchingPlaces
const ALL_MOCK_PLACES: ID[] = [
  PLACE_PARK,
  PLACE_CAFE,
  PLACE_BAR,
  PLACE_HISTORIC,
  PLACE_BOARDWALK,
];

// Principle: users pick preference tags or describe their desired "vibe" in natural language,
// which gets translated into interest tags by LLMs, so places can be filtered to match their
// preferences
Deno.test("Principle: Users manage preferences and filter places", async () => {
  console.log("\n=== Testing Principle Fulfillment for InterestFilter ===");
  const [db, client] = await testDb();
  const concept = new InterestFilterConcept(db);

  try {
    // Ensure initial AllowedTags are populated by the constructor
    const initialTags = await concept.allowedTags.find({}).toArray();
    assertEquals(
      initialTags.length > 0,
      true,
      "AllowedTags should be initialized.",
    );
    console.log(
      `  ✓ Initial AllowedTags populated (${initialTags.length} tags)`,
    );

    // 1. User Alice picks preference tags (manual)
    console.log("\n[ACTION] Alice: setPreferences (manual)");
    const aliceManualTags = ["quiet_spaces", "waterfront_views"];
    console.log(
      `  Input: { userId: ${USER_ALICE}, tags: [${
        aliceManualTags.join(", ")
      }] }`,
    );
    const aliceSetPrefsResult = await concept.setPreferences({
      userId: USER_ALICE,
      tags: aliceManualTags,
    });
    console.log("  Output:", aliceSetPrefsResult);
    assertEquals(
      isError(aliceSetPrefsResult),
      false,
      "Alice's manual preferences should be set.",
    );
    console.log(
      `  ✓ Alice's manual preferences set: ${aliceManualTags.join(", ")}`,
    );

    // Verify Alice's preferences
    const alicePrefs = await concept.userPreferences.findOne({
      _id: USER_ALICE,
    });
    assertExists(alicePrefs, "Alice's UserPreferences should exist.");
    assertEquals(
      alicePrefs.tags,
      aliceManualTags,
      "Alice's preferences tags should match.",
    );
    assertEquals(
      alicePrefs.source,
      "manual",
      "Alice's preferences source should be 'manual'.",
    );
    console.log(
      `  [VERIFY] Alice's preferences in DB: ${JSON.stringify(alicePrefs)}`,
    );

    // 2. User Bob describes his desired "vibe" in natural language (LLM inference)
    console.log("\n[ACTION] Bob: inferPreferencesFromText (LLM)");
    const bobVibeText =
      "I want a calm place near water to relax, definitely not crowded.";
    console.log(`  Input: { userId: ${USER_BOB}, text: "${bobVibeText}" }`);
    const bobInferPrefsResult = await concept.inferPreferencesFromText({
      userId: USER_BOB,
      text: bobVibeText,
    });
    console.log("  Output:", bobInferPrefsResult);
    assertEquals(
      isError(bobInferPrefsResult),
      false,
      "Bob's inferred preferences should be processed.",
    );
    const bobInferred = bobInferPrefsResult as {
      tags: string[];
      exclusions: string[];
    };
    assertExists(bobInferred, "Bob's inferred result should exist.");
    assertEquals(bobInferred.tags.includes("quiet_spaces"), true);
    assertEquals(bobInferred.tags.includes("waterfront_views"), true);
    assertEquals(bobInferred.tags.includes("not_crowded"), true);
    assertEquals(bobInferred.exclusions.length, 0); // Based on mock LLM for this text
    console.log(
      `  ✓ Bob's inferred preferences: ${
        bobInferred.tags.join(", ")
      }, exclusions: ${bobInferred.exclusions.join(", ")}`,
    );

    // Verify Bob's inferred state and updated preferences
    const bobInferredState = await concept.userInferredPrefs.findOne({
      _id: USER_BOB,
    });
    assertExists(bobInferredState, "Bob's UserInferredPrefs should exist.");
    assertEquals(bobInferredState.tags.includes("quiet_spaces"), true);
    const bobPrefs = await concept.userPreferences.findOne({ _id: USER_BOB });
    assertExists(bobPrefs, "Bob's UserPreferences should exist.");
    assertEquals(
      bobPrefs.tags,
      bobInferred.tags,
      "Bob's preferences tags should match inferred.",
    );
    assertEquals(
      bobPrefs.source,
      "llm",
      "Bob's preferences source should be 'llm'.",
    );
    console.log(
      `  [VERIFY] Bob's inferred state in DB: ${
        JSON.stringify(bobInferredState)
      }`,
    );
    console.log(
      `  [VERIFY] Bob's preferences in DB: ${JSON.stringify(bobPrefs)}`,
    );

    // 3. Tag places with relevant tags
    console.log("\n[ACTION] Tagging places for matching...");
    await concept.tagPlace({ placeId: PLACE_PARK, tag: "quiet_spaces" });
    await concept.tagPlace({ placeId: PLACE_PARK, tag: "waterfront_views" });
    await concept.tagPlace({ placeId: PLACE_CAFE, tag: "coffee_nooks" });
    await concept.tagPlace({ placeId: PLACE_CAFE, tag: "quiet_spaces" });
    await concept.tagPlace({ placeId: PLACE_BAR, tag: "lively_nightlife" });
    await concept.tagPlace({ placeId: PLACE_BAR, tag: "live_music" });
    await concept.tagPlace({ placeId: PLACE_HISTORIC, tag: "historic_charms" });
    console.log(
      `  ✓ Places tagged: ${PLACE_PARK}, ${PLACE_CAFE}, ${PLACE_BAR}, ${PLACE_HISTORIC}`,
    );

    // Verify tags for a place
    const parkTags = await concept.placeTags.findOne({ _id: PLACE_PARK });
    assertExists(parkTags, "Park tags should exist.");
    assertEquals(
      parkTags.tags.sort(),
      ["quiet_spaces", "waterfront_views"].sort(),
      "Park tags should match.",
    );
    console.log(
      `  [VERIFY] ${PLACE_PARK} tags: ${JSON.stringify(parkTags?.tags)}`,
    );

    // 4. Alice filters places to match her preferences
    console.log("\n[ACTION] Alice: getMatchingPlaces");
    console.log(
      `  Input: { userId: ${USER_ALICE}, places: [${
        ALL_MOCK_PLACES.join(", ")
      }] }`,
    );
    const aliceMatchesResult = await concept.getMatchingPlaces({
      userId: USER_ALICE,
      places: ALL_MOCK_PLACES,
    });
    console.log("  Output:", aliceMatchesResult);
    assertEquals(
      isError(aliceMatchesResult),
      false,
      "Alice should successfully get matching places.",
    );
    const aliceMatches = (aliceMatchesResult as { matches: ID[] }).matches;
    assertEquals(
      aliceMatches.sort(),
      [PLACE_PARK, PLACE_CAFE].sort(), // Park matches both, Cafe matches quiet_spaces
      "Alice should match Park and Cafe.",
    );
    console.log(`  ✓ Alice's matched places: ${aliceMatches.join(", ")}`);

    // 5. Bob filters places to match his inferred preferences
    console.log("\n[ACTION] Bob: getMatchingPlaces");
    console.log(
      `  Input: { userId: ${USER_BOB}, places: [${
        ALL_MOCK_PLACES.join(", ")
      }] }`,
    );
    const bobMatchesResult = await concept.getMatchingPlaces({
      userId: USER_BOB,
      places: ALL_MOCK_PLACES,
    });
    console.log("  Output:", bobMatchesResult);
    assertEquals(
      isError(bobMatchesResult),
      false,
      "Bob should successfully get matching places.",
    );
    const bobMatches = (bobMatchesResult as { matches: ID[] }).matches;
    assertEquals(
      bobMatches.sort(),
      [PLACE_PARK, PLACE_CAFE].sort(), // Park matches quiet_spaces, waterfront_views. Cafe matches quiet_spaces
      "Bob should match Park and Cafe.",
    );
    console.log(`  ✓ Bob's matched places: ${bobMatches.join(", ")}`);

    // Test with exclusions for Bob
    console.log("\n[ACTION] Bob: inferPreferencesFromText with exclusions");
    const bobExclusionVibeText =
      "I want quiet places, but avoid anything with loud music or nightlife.";
    console.log(
      `  Input: { userId: ${USER_BOB}, text: "${bobExclusionVibeText}" }`,
    );
    const bobInferExclusionResult = await concept.inferPreferencesFromText({
      userId: USER_BOB,
      text: bobExclusionVibeText,
    });
    console.log("  Output:", bobInferExclusionResult);
    assertEquals(
      isError(bobInferExclusionResult),
      false,
      "Bob's exclusion preferences should be processed.",
    );
    const bobExclusions =
      (bobInferExclusionResult as { exclusions: string[] }).exclusions;
    assertEquals(
      bobExclusions.includes("lively_nightlife"),
      true,
      "Bob should now exclude lively_nightlife.",
    );
    assertEquals(
      bobExclusions.includes("live_music"),
      true,
      "Bob should now exclude live_music.",
    );
    console.log(`  ✓ Bob's inferred exclusions: ${bobExclusions.join(", ")}`);

    console.log("\n[ACTION] Bob: getMatchingPlaces with exclusions applied");
    console.log(
      `  Input: { userId: ${USER_BOB}, places: [${
        ALL_MOCK_PLACES.join(", ")
      }] }`,
    );
    const bobMatchesWithExclusionsResult = await concept.getMatchingPlaces({
      userId: USER_BOB,
      places: ALL_MOCK_PLACES,
    });
    console.log("  Output:", bobMatchesWithExclusionsResult);
    assertEquals(
      isError(bobMatchesWithExclusionsResult),
      false,
      "Bob should successfully get matching places with exclusions.",
    );
    const bobMatchesWithExclusions =
      (bobMatchesWithExclusionsResult as { matches: ID[] }).matches;
    assertEquals(
      bobMatchesWithExclusions.sort(),
      [PLACE_PARK, PLACE_CAFE].sort(), // PLACE_BAR (lively_nightlife, live_music) should now be excluded
      "Bob's matches should exclude the bar due to exclusions.",
    );
    console.log(
      `  ✓ Bob's matched places with exclusions: ${
        bobMatchesWithExclusions.join(", ")
      }`,
    );

    console.log(
      "\n✅ Principle demonstrated: Users can manage preferences (manual/LLM) and filter places effectively, including with exclusions.",
    );
  } finally {
    await client.close();
  }
});

Deno.test("Action: setPreferences successfully sets and updates user preferences", async () => {
  console.log("\n=== Testing setPreferences Action ===");
  const [db, client] = await testDb();
  const concept = new InterestFilterConcept(db);

  try {
    // Test Case 1: Set preferences successfully
    console.log("\n[TEST] Set preferences for Charlie successfully");
    const tags1 = ["nature_walks", "sunset_spots"];
    console.log(
      `  Input: { userId: ${USER_CHARLIE}, tags: [${tags1.join(", ")}] }`,
    );
    const result1 = await concept.setPreferences({
      userId: USER_CHARLIE,
      tags: tags1,
    });
    console.log("  Output:", result1);
    assertEquals(
      isError(result1),
      false,
      "Should set preferences successfully.",
    );
    const prefs1 = await concept.userPreferences.findOne({ _id: USER_CHARLIE });
    assertExists(prefs1);
    assertEquals(prefs1.tags.sort(), tags1.sort());
    assertEquals(prefs1.source, "manual");
    console.log(`  ✓ Charlie's preferences set: ${JSON.stringify(prefs1)}`);

    // Test Case 2: Update preferences successfully
    console.log("\n[TEST] Update Charlie's preferences");
    const tags2 = ["coffee_nooks"];
    console.log(
      `  Input: { userId: ${USER_CHARLIE}, tags: [${tags2.join(", ")}] }`,
    );
    const result2 = await concept.setPreferences({
      userId: USER_CHARLIE,
      tags: tags2,
    });
    console.log("  Output:", result2);
    assertEquals(
      isError(result2),
      false,
      "Should update preferences successfully.",
    );
    const prefs2 = await concept.userPreferences.findOne({ _id: USER_CHARLIE });
    assertExists(prefs2);
    assertEquals(prefs2.tags.sort(), tags2.sort());
    assertEquals(prefs2.source, "manual");
    console.log(`  ✓ Charlie's preferences updated: ${JSON.stringify(prefs2)}`);

    // Test Case 3: Reject empty tags
    console.log("\n[TEST] Reject setPreferences with empty tags");
    console.log(`  Input: { userId: ${USER_CHARLIE}, tags: [] }`);
    const resultEmpty = await concept.setPreferences({
      userId: USER_CHARLIE,
      tags: [],
    });
    console.log("  Output:", resultEmpty);
    assertEquals(
      isError(resultEmpty),
      true,
      "Should return an error for empty tags.",
    );
    assertEquals(
      (resultEmpty as { error: string }).error,
      "Tags cannot be empty.",
    );
    console.log(`  ✓ Correctly rejected empty tags`);

    // Test Case 4: Reject invalid tags (not in AllowedTags)
    console.log("\n[TEST] Reject setPreferences with invalid tags");
    console.log(
      `  Input: { userId: ${USER_CHARLIE}, tags: ["invalid_tag_1", "quiet_spaces"] }`,
    );
    const resultInvalid = await concept.setPreferences({
      userId: USER_CHARLIE,
      tags: ["invalid_tag_1", "quiet_spaces"],
    });
    console.log("  Output:", resultInvalid);
    assertEquals(
      isError(resultInvalid),
      true,
      "Should return an error for invalid tags.",
    );
    assertEquals(
      (resultInvalid as { error: string }).error,
      "Invalid tags provided: invalid_tag_1",
    );
    console.log(`  ✓ Correctly rejected invalid tags`);

    // Test Case 5: Reject too many tags (over 7)
    console.log("\n[TEST] Reject setPreferences with too many tags");
    const manyTags = [
      "quiet_spaces",
      "waterfront_views",
      "nature_walks",
      "sunset_spots",
      "not_crowded",
      "short_drive",
      "instagram_worthy",
      "lively_nightlife", // 8 tags
    ];
    console.log(
      `  Input: { userId: ${USER_CHARLIE}, tags: [${manyTags.join(", ")}] }`,
    );
    const resultTooMany = await concept.setPreferences({
      userId: USER_CHARLIE,
      tags: manyTags,
    });
    console.log("  Output:", resultTooMany);
    assertEquals(
      isError(resultTooMany),
      true,
      "Should return an error for too many tags.",
    );
    assertEquals(
      (resultTooMany as { error: string }).error,
      "Too many tags. Maximum 7 allowed.",
    );
    console.log(`  ✓ Correctly rejected too many tags`);

    console.log("\n✅ All setPreferences requirements and effects verified.");
  } finally {
    await client.close();
  }
});

Deno.test("Action: inferPreferencesFromText interprets text and updates user preferences", async () => {
  console.log("\n=== Testing inferPreferencesFromText Action ===");
  const [db, client] = await testDb();
  const concept = new InterestFilterConcept(db);

  try {
    // Test Case 1: Successful inference from text
    console.log("\n[TEST] Infer preferences for Alice from positive text");
    const aliceText1 =
      "I really love quiet places, especially with nature walks.";
    console.log(`  Input: { userId: ${USER_ALICE}, text: "${aliceText1}" }`);
    const result1 = await concept.inferPreferencesFromText({
      userId: USER_ALICE,
      text: aliceText1,
    });
    console.log("  Output:", result1);
    assertEquals(
      isError(result1),
      false,
      "Should infer preferences successfully.",
    );
    const inferred1 = result1 as {
      tags: string[];
      exclusions: string[];
      confidence: number;
      warnings: string[];
    };
    assertEquals(inferred1.tags.includes("quiet_spaces"), true);
    assertEquals(inferred1.tags.includes("nature_walks"), true);
    assertEquals(inferred1.exclusions.length, 0);
    assertNotEquals(
      inferred1.confidence,
      0.5,
      "Confidence should be normal for clear text.",
    );
    assertEquals(inferred1.warnings.length, 0);

    const aliceInferredDb1 = await concept.userInferredPrefs.findOne({
      _id: USER_ALICE,
    });
    assertExists(aliceInferredDb1);
    assertEquals(aliceInferredDb1.tags.sort(), inferred1.tags.sort());
    assertEquals(
      aliceInferredDb1.exclusions.sort(),
      inferred1.exclusions.sort(),
    );
    assertEquals(aliceInferredDb1.lastPrompt, aliceText1);

    const alicePrefsDb1 = await concept.userPreferences.findOne({
      _id: USER_ALICE,
    });
    assertExists(alicePrefsDb1);
    assertEquals(alicePrefsDb1.tags.sort(), inferred1.tags.sort());
    assertEquals(alicePrefsDb1.source, "llm");
    console.log(
      `  ✓ Alice's preferences inferred and stored: ${
        JSON.stringify(inferred1)
      }`,
    );

    // Test Case 2: Inference with explicit exclusions and low confidence
    console.log(
      "\n[TEST] Infer preferences for Bob from text with exclusions and low confidence",
    );
    const bobText =
      "I want places for relaxing, but absolutely no noisy parties. I'm not sure though.";
    console.log(`  Input: { userId: ${USER_BOB}, text: "${bobText}" }`);
    const result2 = await concept.inferPreferencesFromText({
      userId: USER_BOB,
      text: bobText,
    });
    console.log("  Output:", result2);
    assertEquals(
      isError(result2),
      false,
      "Should infer preferences successfully.",
    );
    const inferred2 = result2 as {
      tags: string[];
      exclusions: string[];
      confidence: number;
      warnings: string[];
      needsConfirmation: boolean;
    };
    assertEquals(inferred2.tags.includes("quiet_spaces"), true);
    assertEquals(inferred2.exclusions.includes("lively_nightlife"), true);
    assertEquals(
      inferred2.confidence < 0.65,
      true,
      "Confidence should be low.",
    );
    assertEquals(
      inferred2.needsConfirmation,
      true,
      "needsConfirmation flag should be true.",
    );
    assertEquals(
      inferred2.warnings.length > 0,
      true,
      "Warnings should be present.",
    );
    console.log(
      `  ✓ Bob's preferences inferred with exclusions, low confidence: ${
        JSON.stringify(inferred2)
      }`,
    );

    // Test Case 3: Reject empty text input
    console.log("\n[TEST] Reject inferPreferencesFromText with empty text");
    console.log(`  Input: { userId: ${USER_CHARLIE}, text: "" }`);
    const resultEmptyText = await concept.inferPreferencesFromText({
      userId: USER_CHARLIE,
      text: "",
    });
    console.log("  Output:", resultEmptyText);
    assertEquals(
      isError(resultEmptyText),
      true,
      "Should return an error for empty text.",
    );
    assertEquals(
      (resultEmptyText as { error: string }).error,
      "Text cannot be empty.",
    );
    console.log(`  ✓ Correctly rejected empty text`);

    // Test Case 4: Simulate LLM returning too many tags (should be truncated and warn)
    console.log(
      "\n[TEST] LLM returns too many tags (should warn and truncate)",
    );
    // Temporarily override _mockLLMCall to return many tags
    const originalMockLLMCall = concept["_mockLLMCall"];
    concept["_mockLLMCall"] = (text, _radius, _locationHint) => {
      const allAllowedTags = [
        "quiet_spaces",
        "waterfront_views",
        "nature_walks",
        "sunset_spots",
        "not_crowded",
        "short_drive",
        "instagram_worthy",
        "lively_nightlife",
        "live_music",
      ]; // 9 tags
      return {
        tags: allAllowedTags,
        exclusions: [],
        confidence: 0.8,
        rationale: "mock LLM too many tags",
        warnings: [],
      };
    };
    const resultManyTags = await concept.inferPreferencesFromText({
      userId: USER_CHARLIE,
      text: "I want everything!",
    });
    console.log("  Output:", resultManyTags);
    assertEquals(
      isError(resultManyTags),
      false,
      "Should process despite too many tags.",
    );
    const manyTagsResult = resultManyTags as {
      tags: string[];
      warnings: string[];
    };
    assertEquals(
      manyTagsResult.tags.length,
      7,
      "Tags should be truncated to 7.",
    );
    assertEquals(
      manyTagsResult.warnings.some((w) => w.includes("too many tags")),
      true,
      "Should contain a warning about too many tags.",
    );
    console.log(`  ✓ LLM with too many tags handled: truncated, warned.`);
    concept["_mockLLMCall"] = originalMockLLMCall; // Restore original mock

    console.log(
      "\n✅ All inferPreferencesFromText requirements and effects verified.",
    );
  } finally {
    await client.close();
  }
});

Deno.test("Action: tagPlace associates tags with places and enforces requirements", async () => {
  console.log("\n=== Testing tagPlace Action ===");
  const [db, client] = await testDb();
  const concept = new InterestFilterConcept(db);

  try {
    // Test Case 1: Tag a place successfully for the first time
    console.log("\n[TEST] Tag PLACE_HISTORIC with 'historic_charms'");
    const tag1 = "historic_charms";
    console.log(`  Input: { placeId: ${PLACE_HISTORIC}, tag: "${tag1}" }`);
    const result1 = await concept.tagPlace({
      placeId: PLACE_HISTORIC,
      tag: tag1,
    });
    console.log("  Output:", result1);
    assertEquals(isError(result1), false, "Should tag place successfully.");
    const placeTags1 = await concept.placeTags.findOne({ _id: PLACE_HISTORIC });
    assertExists(placeTags1);
    assertEquals(placeTags1.tags, [tag1]);
    console.log(
      `  ✓ ${PLACE_HISTORIC} tags: ${JSON.stringify(placeTags1.tags)}`,
    );

    // Test Case 2: Add another tag to an existing place
    console.log("\n[TEST] Add 'instagram_worthy' to PLACE_HISTORIC");
    const tag2 = "instagram_worthy";
    console.log(`  Input: { placeId: ${PLACE_HISTORIC}, tag: "${tag2}" }`);
    const result2 = await concept.tagPlace({
      placeId: PLACE_HISTORIC,
      tag: tag2,
    });
    console.log("  Output:", result2);
    assertEquals(
      isError(result2),
      false,
      "Should add another tag successfully.",
    );
    const placeTags2 = await concept.placeTags.findOne({ _id: PLACE_HISTORIC });
    assertExists(placeTags2);
    assertEquals(placeTags2.tags.sort(), [tag1, tag2].sort());
    console.log(
      `  ✓ ${PLACE_HISTORIC} tags updated: ${JSON.stringify(placeTags2.tags)}`,
    );

    // Test Case 3: Attempt to add an already existing tag (should be idempotent)
    console.log(
      "\n[TEST] Add 'historic_charms' again to PLACE_HISTORIC (should be idempotent)",
    );
    console.log(`  Input: { placeId: ${PLACE_HISTORIC}, tag: "${tag1}" }`);
    const result3 = await concept.tagPlace({
      placeId: PLACE_HISTORIC,
      tag: tag1,
    });
    console.log("  Output:", result3);
    assertEquals(
      isError(result3),
      false,
      "Should succeed and not add duplicate.",
    );
    const placeTags3 = await concept.placeTags.findOne({ _id: PLACE_HISTORIC });
    assertExists(placeTags3);
    assertEquals(
      placeTags3.tags.sort(),
      [tag1, tag2].sort(),
      "Tags should remain the same.",
    );
    console.log(
      `  ✓ Tagging existing tag is idempotent: ${
        JSON.stringify(placeTags3.tags)
      }`,
    );

    // Test Case 4: Reject invalid tag
    console.log("\n[TEST] Reject tagPlace with an invalid tag");
    const invalidTag = "non_existent_tag";
    console.log(
      `  Input: { placeId: ${PLACE_BOARDWALK}, tag: "${invalidTag}" }`,
    );
    const resultInvalid = await concept.tagPlace({
      placeId: PLACE_BOARDWALK,
      tag: invalidTag,
    });
    console.log("  Output:", resultInvalid);
    assertEquals(
      isError(resultInvalid),
      true,
      "Should return an error for invalid tag.",
    );
    assertEquals(
      (resultInvalid as { error: string }).error,
      `Tag '${invalidTag}' is not an allowed tag.`,
    );
    console.log(`  ✓ Correctly rejected invalid tag`);

    console.log("\n✅ All tagPlace requirements and effects verified.");
  } finally {
    await client.close();
  }
});

Deno.test("Action: clearPreferences removes user preferences", async () => {
  console.log("\n=== Testing clearPreferences Action ===");
  const [db, client] = await testDb();
  const concept = new InterestFilterConcept(db);

  try {
    // Setup: Set manual and inferred preferences for Alice
    console.log("\n[SETUP] Set manual preferences for Alice");
    await concept.setPreferences({
      userId: USER_ALICE,
      tags: ["quiet_spaces"],
    });
    console.log("\n[SETUP] Infer preferences for Alice");
    await concept.inferPreferencesFromText({
      userId: USER_ALICE,
      text: "some text",
    });

    let aliceManualPrefs = await concept.userPreferences.findOne({
      _id: USER_ALICE,
    });
    let aliceInferredPrefs = await concept.userInferredPrefs.findOne({
      _id: USER_ALICE,
    });
    assertExists(aliceManualPrefs, "Alice should have manual preferences.");
    assertExists(aliceInferredPrefs, "Alice should have inferred preferences.");
    console.log(`  ✓ Alice has existing preferences.`);

    // Test Case 1: Clear preferences successfully
    console.log("\n[TEST] Clear preferences for Alice");
    console.log(`  Input: { userId: ${USER_ALICE} }`);
    const clearResult = await concept.clearPreferences({ userId: USER_ALICE });
    console.log("  Output:", clearResult);
    assertEquals(
      isError(clearResult),
      false,
      "Should clear preferences successfully.",
    );

    aliceManualPrefs = await concept.userPreferences.findOne({
      _id: USER_ALICE,
    });
    aliceInferredPrefs = await concept.userInferredPrefs.findOne({
      _id: USER_ALICE,
    });
    assertEquals(aliceManualPrefs, null, "UserPreferences should be removed.");
    assertEquals(
      aliceInferredPrefs,
      null,
      "UserInferredPrefs should be removed.",
    );
    console.log(`  ✓ Alice's preferences successfully cleared from DB.`);

    // Test Case 2: Clearing preferences for a user with no preferences (should be idempotent)
    console.log(
      "\n[TEST] Clear preferences for Charlie who has no preferences",
    );
    console.log(`  Input: { userId: ${USER_CHARLIE} }`);
    const charlieClearResult = await concept.clearPreferences({
      userId: USER_CHARLIE,
    });
    console.log("  Output:", charlieClearResult);
    assertEquals(
      isError(charlieClearResult),
      false,
      "Should succeed even if no preferences exist.",
    );
    const charlieManualPrefs = await concept.userPreferences.findOne({
      _id: USER_CHARLIE,
    });
    assertEquals(
      charlieManualPrefs,
      null,
      "Charlie still should have no manual preferences.",
    );
    console.log(`  ✓ Clearing non-existent preferences is idempotent.`);

    console.log("\n✅ All clearPreferences effects verified.");
  } finally {
    await client.close();
  }
});

Deno.test("Action: getMatchingPlaces returns relevant places based on user preferences and exclusions", async () => {
  console.log("\n=== Testing getMatchingPlaces Action ===");
  const [db, client] = await testDb();
  const concept = new InterestFilterConcept(db);

  try {
    // Setup: Tag all mock places
    console.log("\n[SETUP] Tagging all mock places...");
    await concept.tagPlace({ placeId: PLACE_PARK, tag: "quiet_spaces" });
    await concept.tagPlace({ placeId: PLACE_PARK, tag: "waterfront_views" });
    await concept.tagPlace({ placeId: PLACE_CAFE, tag: "coffee_nooks" });
    await concept.tagPlace({ placeId: PLACE_CAFE, tag: "quiet_spaces" });
    await concept.tagPlace({ placeId: PLACE_BAR, tag: "lively_nightlife" });
    await concept.tagPlace({ placeId: PLACE_BAR, tag: "live_music" });
    await concept.tagPlace({ placeId: PLACE_HISTORIC, tag: "historic_charms" });
    await concept.tagPlace({
      placeId: PLACE_BOARDWALK,
      tag: "waterfront_views",
    });
    await concept.tagPlace({
      placeId: PLACE_BOARDWALK,
      tag: "family_friendly",
    });
    console.log(`  ✓ All mock places tagged.`);

    // Setup: User Alice's preferences: quiet_spaces, waterfront_views (score 2)
    console.log(
      "\n[SETUP] Alice sets preferences: quiet_spaces, waterfront_views",
    );
    await concept.setPreferences({
      userId: USER_ALICE,
      tags: ["quiet_spaces", "waterfront_views"],
    });

    // Test Case 1: Alice gets matching places without exclusions
    console.log("\n[TEST] Alice gets matches without exclusions");
    console.log(
      `  Input: { userId: ${USER_ALICE}, places: [${
        ALL_MOCK_PLACES.join(", ")
      }] }`,
    );
    const result1 = await concept.getMatchingPlaces({
      userId: USER_ALICE,
      places: ALL_MOCK_PLACES,
    });
    console.log("  Output:", result1);
    assertEquals(
      isError(result1),
      false,
      "Should get matching places successfully.",
    );
    const matches1 = (result1 as { matches: ID[] }).matches;
    // PLACE_PARK (quiet_spaces, waterfront_views) - Score 2
    // PLACE_CAFE (quiet_spaces) - Score 1
    // PLACE_BOARDWALK (waterfront_views) - Score 1

    // Verify order FIRST (Park:2, Cafe:1, Boardwalk:1 - order of Cafe/Boardwalk can vary if scores are equal and no secondary sort)
    // For this mock, simple scores, so Park should be first.
    assertEquals(matches1[0], PLACE_PARK, "Park should be highest ranked.");

    // Then verify content (using sort for comparison)
    assertEquals(
      [...matches1].sort(), // Use spread to avoid mutating original array
      [PLACE_PARK, PLACE_CAFE, PLACE_BOARDWALK].sort(),
      "Alice should match Park, Cafe, and Boardwalk.",
    );
    console.log(`  ✓ Alice's matches: ${matches1.join(", ")}`);

    // Setup: User Alice's inferred preferences with exclusions: "lively_nightlife", "live_music"
    console.log(
      "\n[SETUP] Alice infers preferences with exclusions: avoids lively_nightlife, live_music",
    );
    await concept.inferPreferencesFromText({
      userId: USER_ALICE,
      text: "I want a quiet place, but avoid anything with music or parties.",
    });
    const aliceInferredWithExclusions = await concept.userInferredPrefs.findOne(
      { _id: USER_ALICE },
    );
    assertExists(aliceInferredWithExclusions);
    assertEquals(
      aliceInferredWithExclusions.exclusions.includes("lively_nightlife"),
      true,
    );
    assertEquals(
      aliceInferredWithExclusions.exclusions.includes("live_music"),
      true,
    );
    console.log(
      `  ✓ Alice now has exclusions: ${
        aliceInferredWithExclusions.exclusions.join(", ")
      }`,
    );

    // Re-set Alice's manual preferences to include a tag that would be excluded by inferred prefs
    // This demonstrates that inferred exclusions override or down-rank.
    console.log(
      "\n[SETUP] Alice also sets manual preference for 'lively_nightlife'",
    );
    await concept.setPreferences({
      userId: USER_ALICE,
      tags: ["quiet_spaces", "lively_nightlife"],
    });

    // Test Case 2: Alice gets matching places with exclusions (PLACE_BAR should be excluded)
    console.log(
      "\n[TEST] Alice gets matches WITH exclusions (PLACE_BAR should be excluded)",
    );
    console.log(
      `  Input: { userId: ${USER_ALICE}, places: [${
        ALL_MOCK_PLACES.join(", ")
      }] }`,
    );
    const result2 = await concept.getMatchingPlaces({
      userId: USER_ALICE,
      places: ALL_MOCK_PLACES,
    });
    console.log("  Output:", result2);
    assertEquals(
      isError(result2),
      false,
      "Should get matching places successfully.",
    );
    const matches2 = (result2 as { matches: ID[] }).matches;
    // PLACE_BAR has "lively_nightlife" which is in Alice's exclusions, so it should be removed.
    // Alice's preferences are now ["quiet_spaces", "lively_nightlife"]
    // PLACE_PARK matches "quiet_spaces", PLACE_CAFE matches "quiet_spaces"
    // PLACE_BOARDWALK has "waterfront_views" which is no longer in Alice's preferences, so it shouldn't match
    assertEquals(
      matches2.includes(PLACE_BAR),
      false,
      "PLACE_BAR should be excluded due to inferred exclusions.",
    );
    assertEquals(
      [...matches2].sort(),
      [PLACE_PARK, PLACE_CAFE].sort(),
      "Alice's matches should exclude the bar and only include places matching current preferences.",
    );
    console.log(`  ✓ Alice's matches after exclusions: ${matches2.join(", ")}`);

    // Test Case 3: Reject getMatchingPlaces for user with no preferences
    console.log(
      "\n[TEST] Reject getMatchingPlaces for user with no preferences",
    );
    console.log(
      `  Input: { userId: ${USER_CHARLIE}, places: [${
        ALL_MOCK_PLACES.join(", ")
      }] }`,
    );
    const resultNoPrefs = await concept.getMatchingPlaces({
      userId: USER_CHARLIE,
      places: ALL_MOCK_PLACES,
    });
    console.log("  Output:", resultNoPrefs);
    assertEquals(
      isError(resultNoPrefs),
      true,
      "Should return an error for user with no preferences.",
    );
    assertEquals(
      (resultNoPrefs as { error: string }).error,
      "User has no preferences set to filter places.",
    );
    console.log(`  ✓ Correctly rejected user with no preferences`);

    // Test Case 4: Reject getMatchingPlaces with empty places list
    console.log("\n[TEST] Reject getMatchingPlaces with empty places list");
    console.log(`  Input: { userId: ${USER_ALICE}, places: [] }`);
    const resultEmptyPlaces = await concept.getMatchingPlaces({
      userId: USER_ALICE,
      places: [],
    });
    console.log("  Output:", resultEmptyPlaces);
    assertEquals(
      isError(resultEmptyPlaces),
      true,
      "Should return an error for empty places list.",
    );
    assertEquals(
      (resultEmptyPlaces as { error: string }).error,
      "No places provided for matching.",
    );
    console.log(`  ✓ Correctly rejected empty places list`);

    console.log(
      "\n✅ All getMatchingPlaces requirements and effects verified.",
    );
  } finally {
    await client.close();
  }
});

```
