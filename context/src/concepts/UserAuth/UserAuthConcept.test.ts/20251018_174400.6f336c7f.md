---
timestamp: 'Sat Oct 18 2025 17:44:00 GMT-0400 (Eastern Daylight Time)'
content_id: 6f336c7fe0449b283b1185ac6dd33b86481118d94f9ac735fc2521be6758adf5
---

# file: src/concepts/UserAuth/UserAuthConcept.test.ts

```typescript
import {
  assertEquals,
  assertExists,
  assertNotEquals,
  assertNull,
  assertObjectMatch,
} from "jsr:@std/assert";
import { testDb } from "@utils/database.ts";
import UserAuthConcept from "./UserAuthConcept.ts";
import { ID } from "@utils/types.ts";
import { freshID } from "@utils/database.ts";

Deno.test("UserAuthConcept", async (t) => {
  let userAuth: UserAuthConcept;
  let dbClient: any; // MongoClient type is needed to close

  Deno.test.beforeAll(async () => {
    const [db, client] = await testDb();
    userAuth = new UserAuthConcept(db);
    dbClient = client; // Store client to close later
  });

  Deno.test.afterAll(async () => {
    await dbClient.close();
  });

  // --- Principle Test ---
  await t.step(
    "Principle: users must register and log in before contributing; moderators can verify content",
    async () => {
      console.log(
        "\n--- Principle Test: Register, Login, Grant Moderator ---",
      );

      // 1. Register a regular user (Alice)
      console.log("Action: Register Alice");
      const registerAliceResult = await userAuth.registerUser({
        username: "alice",
        password: "passwordAlice",
      });
      if ("error" in registerAliceResult) {
        throw new Error(
          `Failed to register Alice: ${registerAliceResult.error}`,
        );
      }
      const aliceId = registerAliceResult.userId;
      assertExists(aliceId, "Alice's userId should be returned");
      console.log(`- Alice Registered (ID: ${aliceId})`);

      // 2. Register a user who will become a moderator (Bob)
      console.log("Action: Register Bob");
      const registerBobResult = await userAuth.registerUser({
        username: "bob",
        password: "passwordBob",
      });
      if ("error" in registerBobResult) {
        throw new Error(`Failed to register Bob: ${registerBobResult.error}`);
      }
      const bobId = registerBobResult.userId;
      assertExists(bobId, "Bob's userId should be returned");
      console.log(`- Bob Registered (ID: ${bobId})`);

      // 3. Register a SuperAdmin user (for bootstrapping moderator privileges in test)
      console.log("Action: Register SuperAdmin");
      const registerAdminResult = await userAuth.registerUser({
        username: "superadmin",
        password: "adminpassword",
      });
      if ("error" in registerAdminResult) {
        throw new Error(
          `Failed to register SuperAdmin: ${registerAdminResult.error}`,
        );
      }
      const adminId = registerAdminResult.userId;
      console.log(`- SuperAdmin Registered (ID: ${adminId})`);

      // 4. Directly set SuperAdmin as moderator for test setup (simulating initial admin bootstrap)
      console.log("Internal Action: Setting SuperAdmin's canModerate to true");
      await userAuth.users.updateOne({ _id: adminId }, {
        $set: { canModerate: true },
      });
      const adminDetailsAfterBootstrap = await userAuth._getUserDetails({
        userId: adminId,
      });
      if ("error" in adminDetailsAfterBootstrap) {
        throw new Error(
          `Failed to get SuperAdmin details: ${adminDetailsAfterBootstrap.error}`,
        );
      }
      assertEquals(
        adminDetailsAfterBootstrap[0].user.canModerate,
        true,
        "SuperAdmin should now be a moderator",
      );
      console.log(`- SuperAdmin is now a moderator`);

      // 5. SuperAdmin logs in to obtain an admin session token
      console.log("Action: SuperAdmin Login");
      const loginAdminResult = await userAuth.login({
        username: "superadmin",
        password: "adminpassword",
      });
      if ("error" in loginAdminResult) {
        throw new Error(
          `Failed to login SuperAdmin: ${loginAdminResult.error}`,
        );
      }
      const adminSession = loginAdminResult.sessionToken;
      assertExists(adminSession, "Admin session token should be returned");
      console.log(`- SuperAdmin Logged In (Session: ${adminSession})`);

      // 6. SuperAdmin grants moderator privilege to Bob
      console.log("Action: Grant Bob Moderator Privilege by SuperAdmin");
      const grantBobResult = await userAuth.grantModerator({
        targetUserId: bobId,
        adminSessionToken: adminSession,
      });
      if ("error" in grantBobResult) {
        throw new Error(
          `Failed to grant Bob moderator: ${grantBobResult.error}`,
        );
      }
      assertEquals(
        grantBobResult.success,
        true,
        "Bob should be granted moderator privileges successfully",
      );
      console.log(`- Bob is now a moderator`);

      // 7. Verify Bob is a moderator using a query
      console.log("Query: Verify Bob's moderator status");
      const bobDetails = await userAuth._getUserDetails({ userId: bobId });
      if ("error" in bobDetails) {
        throw new Error(`Failed to get Bob's details: ${bobDetails.error}`);
      }
      assertEquals(
        bobDetails[0].user.canModerate,
        true,
        "Bob should be a moderator as per principle",
      );
      console.log(
        `- Bob's moderation status verified: ${bobDetails[0].user.canModerate}`,
      );

      // 8. Alice logs in (demonstrates a regular user logging in to contribute)
      console.log("Action: Alice Login");
      const loginAliceResult = await userAuth.login({
        username: "alice",
        password: "passwordAlice",
      });
      if ("error" in loginAliceResult) {
        throw new Error(
          `Failed to login Alice: ${loginAliceResult.error}`,
        );
      }
      const aliceSession = loginAliceResult.sessionToken;
      assertExists(aliceSession, "Alice's session token should be returned");
      console.log(`- Alice Logged In (Session: ${aliceSession})`);

      // Clean up sessions
      console.log("Cleanup: Logging out Alice and SuperAdmin");
      await userAuth.logout({ sessionToken: aliceSession });
      await userAuth.logout({ sessionToken: adminSession });
      console.log("--- Principle Test Completed ---");
    },
  );

  // --- registerUser Action Tests ---
  await t.step("registerUser", async (t) => {
    await t.step("successfully registers a new user", async () => {
      console.log("\n--- Testing registerUser: Success ---");
      const result = await userAuth.registerUser({
        username: "testuser1",
        password: "testpassword",
      });
      console.log("  registerUser result:", result);
      if ("error" in result) {
        throw new Error(`Registration failed unexpectedly: ${result.error}`);
      }
      assertExists(result.userId, "userId should be returned");
      const userDoc = await userAuth.users.findOne({ _id: result.userId });
      assertExists(userDoc, "User should exist in database");
      assertEquals(userDoc.username, "testuser1");
      assertEquals(userDoc.canModerate, false);
      console.log("  - User 'testuser1' registered successfully.");
    });

    await t.step("prevents duplicate usernames", async () => {
      console.log("\n--- Testing registerUser: Duplicate Username ---");
      await userAuth.registerUser({
        username: "duplicateuser",
        password: "pass",
      });
      console.log("  Registered 'duplicateuser' first time.");
      const result = await userAuth.registerUser({
        username: "duplicateuser",
        password: "pass",
      });
      console.log("  registerUser duplicate result:", result);
      assertExists(
        (result as { error: string }).error,
        "Error should be returned for duplicate username",
      );
      assertEquals(
        (result as { error: string }).error,
        "Username already taken",
        "Error message should indicate username taken",
      );
      console.log("  - Duplicate username registration correctly failed.");
    });

    await t.step("requires non-empty password", async () => {
      console.log("\n--- Testing registerUser: Empty Password ---");
      const result = await userAuth.registerUser({
        username: "nopassuser",
        password: "",
      });
      console.log("  registerUser empty password result:", result);
      assertExists(
        (result as { error: string }).error,
        "Error should be returned for empty password",
      );
      assertEquals(
        (result as { error: string }).error,
        "Password cannot be empty",
        "Error message should indicate empty password",
      );
      console.log("  - Empty password registration correctly failed.");
    });
  });

  // --- login Action Tests ---
  await t.step("login", async (t) => {
    await t.step("successfully logs in a registered user", async () => {
      console.log("\n--- Testing login: Success ---");
      await userAuth.registerUser({
        username: "loginuser",
        password: "loginpass",
      });
      console.log("  Registered 'loginuser'.");
      const loginResult = await userAuth.login({
        username: "loginuser",
        password: "loginpass",
      });
      console.log("  login success result:", loginResult);
      if ("error" in loginResult) {
        throw new Error(`Login failed unexpectedly: ${loginResult.error}`);
      }
      assertExists(
        loginResult.sessionToken,
        "Session token should be returned",
      );
      const sessionDoc = await userAuth.activeSessions.findOne({
        _id: loginResult.sessionToken as ID,
      });
      assertExists(sessionDoc, "Session should exist in database");
      console.log("  - User 'loginuser' logged in successfully.");
      await userAuth.logout({ sessionToken: loginResult.sessionToken }); // Clean up
    });

    await t.step("fails with incorrect password", async () => {
      console.log("\n--- Testing login: Incorrect Password ---");
      await userAuth.registerUser({
        username: "badpassuser",
        password: "correctpass",
      });
      console.log("  Registered 'badpassuser'.");
      const loginResult = await userAuth.login({
        username: "badpassuser",
        password: "incorrectpass",
      });
      console.log("  login bad password result:", loginResult);
      assertExists(
        (loginResult as { error: string }).error,
        "Error should be returned for incorrect password",
      );
      assertEquals(
        (loginResult as { error: string }).error,
        "Invalid username or password",
        "Error message should indicate invalid credentials",
      );
      console.log("  - Login with incorrect password correctly failed.");
    });

    await t.step("fails with non-existent username", async () => {
      console.log("\n--- Testing login: Non-existent Username ---");
      const loginResult = await userAuth.login({
        username: "nonexistentuser",
        password: "anypass",
      });
      console.log("  login nonexistent user result:", loginResult);
      assertExists(
        (loginResult as { error: string }).error,
        "Error should be returned for non-existent username",
      );
      assertEquals(
        (loginResult as { error: string }).error,
        "Invalid username or password",
        "Error message should indicate invalid credentials",
      );
      console.log("  - Login with non-existent username correctly failed.");
    });
  });

  // --- logout Action Tests ---
  await t.step("logout", async (t) => {
    await t.step("successfully logs out an active session", async () => {
      console.log("\n--- Testing logout: Success ---");
      await userAuth.registerUser({
        username: "logoutuser",
        password: "logoutpass",
      });
      const loginResult = await userAuth.login({
        username: "logoutuser",
        password: "logoutpass",
      });
      if ("error" in loginResult) {
        throw new Error(`Login failed unexpectedly: ${loginResult.error}`);
      }
      const sessionToken = loginResult.sessionToken;
      console.log(`  Logged in 'logoutuser', session: ${sessionToken}`);

      const logoutResult = await userAuth.logout({ sessionToken });
      console.log("  logout result:", logoutResult);
      assertEquals(
        logoutResult.success,
        true,
        "Logout should return success true",
      );
      const sessionCount = await userAuth.activeSessions.countDocuments({
        _id: sessionToken as ID,
      });
      assertEquals(sessionCount, 0, "Session should be removed from database");
      console.log("  - User 'logoutuser' logged out successfully.");
    });

    await t.step("returns false for a non-existent session", async () => {
      console.log("\n--- Testing logout: Non-existent Session ---");
      const logoutResult = await userAuth.logout({
        sessionToken: "nonexistentSession" as ID,
      });
      console.log("  logout nonexistent result:", logoutResult);
      assertEquals(
        logoutResult.success,
        false,
        "Logout should return success false for non-existent session",
      );
      console.log(
        "  - Logout for non-existent session correctly returned false.",
      );
    });
  });

  // --- getAuthenticatedUser Query Tests ---
  await t.step("getAuthenticatedUser", async (t) => {
    await t.step("returns user profile for valid session", async () => {
      console.log("\n--- Testing getAuthenticatedUser: Valid Session ---");
      const registerResult = await userAuth.registerUser({
        username: "authuser",
        password: "authpass",
      });
      if ("error" in registerResult) throw new Error(registerResult.error);
      const loginResult = await userAuth.login({
        username: "authuser",
        password: "authpass",
      });
      if ("error" in loginResult) throw new Error(loginResult.error);
      const sessionToken = loginResult.sessionToken;
      console.log(
        `  Registered and logged in 'authuser', session: ${sessionToken}`,
      );

      const authUserResult = await userAuth.getAuthenticatedUser({
        sessionToken,
      });
      console.log("  getAuthenticatedUser result:", authUserResult);
      assertExists(
        authUserResult.userProfile,
        "User profile should be returned",
      );
      assertObjectMatch(
        authUserResult.userProfile!,
        {
          userId: registerResult.userId,
          username: "authuser",
          canModerate: false,
        },
        "User profile details should match",
      );
      console.log("  - Authenticated user profile retrieved successfully.");
      await userAuth.logout({ sessionToken }); // Clean up
    });

    await t.step("returns null for invalid session", async () => {
      console.log("\n--- Testing getAuthenticatedUser: Invalid Session ---");
      const authUserResult = await userAuth.getAuthenticatedUser({
        sessionToken: "invalidtoken" as ID,
      });
      console.log(
        "  getAuthenticatedUser invalid session result:",
        authUserResult,
      );
      assertNull(
        authUserResult.userProfile,
        "User profile should be null for invalid session",
      );
      console.log("  - Invalid session correctly returned null profile.");
    });

    await t.step(
      "handles inconsistent session data by cleaning up",
      async () => {
        console.log(
          "\n--- Testing getAuthenticatedUser: Inconsistent Session Data ---",
        );
        const sessionToken: ID = freshID();
        await userAuth.activeSessions.insertOne({
          _id: sessionToken,
          userId: "nonexistentuser" as ID,
          createdAt: new Date(),
        });
        console.log(
          `  Inserted inconsistent session for non-existent user: ${sessionToken}`,
        );

        const authUserResult = await userAuth.getAuthenticatedUser({
          sessionToken,
        });
        console.log(
          "  getAuthenticatedUser inconsistent data result:",
          authUserResult,
        );
        assertNull(
          authUserResult.userProfile,
          "User profile should be null for inconsistent session",
        );

        const sessionCount = await userAuth.activeSessions.countDocuments({
          _id: sessionToken,
        });
        assertEquals(
          sessionCount,
          0,
          "Inconsistent session should be cleaned up",
        );
        console.log(
          "  - Inconsistent session data correctly handled and cleaned up.",
        );
      },
    );
  });

  // --- changePassword Action Tests ---
  await t.step("changePassword", async (t) => {
    await t.step(
      "successfully changes password and invalidates sessions",
      async () => {
        console.log(
          "\n--- Testing changePassword: Success and Invalidation ---",
        );
        const registerResult = await userAuth.registerUser({
          username: "pwdchangeuser",
          password: "oldpass",
        });
        if ("error" in registerResult) throw new Error(registerResult.error);
        const userId = registerResult.userId;
        console.log(`  Registered 'pwdchangeuser' (ID: ${userId})`);

        const loginResult1 = await userAuth.login({
          username: "pwdchangeuser",
          password: "oldpass",
        });
        if ("error" in loginResult1) throw new Error(loginResult1.error);
        const sessionToken1 = loginResult1.sessionToken;
        console.log(`  First login, session: ${sessionToken1}`);

        const loginResult2 = await userAuth.login({
          username: "pwdchangeuser",
          password: "oldpass",
        }); // Another session
        if ("error" in loginResult2) throw new Error(loginResult2.error);
        const sessionToken2 = loginResult2.sessionToken;
        console.log(`  Second login, session: ${sessionToken2}`);

        const changePwdResult = await userAuth.changePassword({
          sessionToken: sessionToken1,
          oldPassword: "oldpass",
          newPassword: "newpass",
        });
        console.log("  changePassword result:", changePwdResult);
        if ("error" in changePwdResult) {
          throw new Error(
            `Password change failed unexpectedly: ${changePwdResult.error}`,
          );
        }
        assertEquals(
          changePwdResult.success,
          true,
          "Password change should succeed",
        );
        console.log("  - Password changed successfully.");

        // Verify old sessions are invalidated
        console.log("  Verifying session invalidation...");
        const auth1 = await userAuth.getAuthenticatedUser({
          sessionToken: sessionToken1,
        });
        assertNull(auth1.userProfile, "Session 1 should be invalidated");
        const auth2 = await userAuth.getAuthenticatedUser({
          sessionToken: sessionToken2,
        });
        assertNull(auth2.userProfile, "Session 2 should be invalidated");
        console.log("  - All previous sessions invalidated.");

        // Verify new password works
        console.log("  Attempting login with new password...");
        const newLoginResult = await userAuth.login({
          username: "pwdchangeuser",
          password: "newpass",
        });
        if ("error" in newLoginResult) {
          throw new Error(
            `Login with new password failed unexpectedly: ${newLoginResult.error}`,
          );
        }
        assertExists(
          newLoginResult.sessionToken,
          "Login with new password should succeed",
        );
        console.log("  - Login with new password successful.");

        // Verify old password no longer works
        console.log("  Attempting login with old password...");
        const oldLoginAttempt = await userAuth.login({
          username: "pwdchangeuser",
          password: "oldpass",
        });
        assertExists(
          (oldLoginAttempt as { error: string }).error,
          "Login with old password should fail",
        );
        console.log("  - Login with old password correctly failed.");
        await userAuth.logout({ sessionToken: newLoginResult.sessionToken }); // Clean up
      },
    );

    await t.step("fails with incorrect old password", async () => {
      console.log("\n--- Testing changePassword: Incorrect Old Password ---");
      const registerResult = await userAuth.registerUser({
        username: "failpwduser",
        password: "correct",
      });
      if ("error" in registerResult) throw new Error(registerResult.error);
      const loginResult = await userAuth.login({
        username: "failpwduser",
        password: "correct",
      });
      if ("error" in loginResult) throw new Error(loginResult.error);
      const sessionToken = loginResult.sessionToken;
      console.log(
        `  Registered and logged in 'failpwduser', session: ${sessionToken}`,
      );

      const changePwdResult = await userAuth.changePassword({
        sessionToken,
        oldPassword: "wrongpass",
        newPassword: "newpass",
      });
      console.log(
        "  changePassword incorrect old pass result:",
        changePwdResult,
      );
      assertExists(
        (changePwdResult as { error: string }).error,
        "Error should be returned",
      );
      assertEquals(
        (changePwdResult as { error: string }).error,
        "Old password does not match",
        "Error message should indicate old password mismatch",
      );
      console.log(
        "  - Password change with incorrect old password correctly failed.",
      );
      await userAuth.logout({ sessionToken }); // Clean up
    });

    await t.step("requires non-empty new password", async () => {
      console.log("\n--- Testing changePassword: Empty New Password ---");
      const registerResult = await userAuth.registerUser({
        username: "emptyoldpwd",
        password: "old",
      });
      if ("error" in registerResult) throw new Error(registerResult.error);
      const loginResult = await userAuth.login({
        username: "emptyoldpwd",
        password: "old",
      });
      if ("error" in loginResult) throw new Error(loginResult.error);
      const sessionToken = loginResult.sessionToken;
      console.log(
        `  Registered and logged in 'emptyoldpwd', session: ${sessionToken}`,
      );

      const changePwdResult = await userAuth.changePassword({
        sessionToken,
        oldPassword: "old",
        newPassword: "",
      });
      console.log("  changePassword empty new pass result:", changePwdResult);
      assertExists(
        (changePwdResult as { error: string }).error,
        "Error should be returned",
      );
      assertEquals(
        (changePwdResult as { error: string }).error,
        "New password cannot be empty",
        "Error message should indicate empty new password",
      );
      console.log(
        "  - Password change with empty new password correctly failed.",
      );
      await userAuth.logout({ sessionToken }); // Clean up
    });
  });

  // --- grantModerator Action Tests ---
  await t.step("grantModerator", async (t) => {
    await t.step("successfully grants moderator privilege", async () => {
      console.log("\n--- Testing grantModerator: Success ---");
      const registerAdminResult = await userAuth.registerUser({
        username: "adminuser",
        password: "adminpass",
      });
      if ("error" in registerAdminResult) {
        throw new Error(registerAdminResult.error);
      }
      const adminId = registerAdminResult.userId;
      await userAuth.users.updateOne({ _id: adminId }, {
        $set: { canModerate: true },
      }); // Bootstrap admin
      const loginAdminResult = await userAuth.login({
        username: "adminuser",
        password: "adminpass",
      });
      if ("error" in loginAdminResult) throw new Error(loginAdminResult.error);
      const adminSession = loginAdminResult.sessionToken;
      console.log(
        `  Admin user setup (ID: ${adminId}, Session: ${adminSession})`,
      );

      const registerTargetResult = await userAuth.registerUser({
        username: "targetuser",
        password: "targetpass",
      });
      if ("error" in registerTargetResult) {
        throw new Error(registerTargetResult.error);
      }
      const targetUserId = registerTargetResult.userId;
      console.log(`  Target user registered (ID: ${targetUserId})`);

      const grantResult = await userAuth.grantModerator({
        targetUserId,
        adminSessionToken: adminSession,
      });
      console.log("  grantModerator result:", grantResult);
      if ("error" in grantResult) {
        throw new Error(
          `Grant moderator failed unexpectedly: ${grantResult.error}`,
        );
      }
      assertEquals(grantResult.success, true, "Grant moderator should succeed");

      const targetUserDetails = await userAuth._getUserDetails({
        userId: targetUserId,
      });
      if ("error" in targetUserDetails) {
        throw new Error(targetUserDetails.error);
      }
      assertEquals(
        targetUserDetails[0].user.canModerate,
        true,
        "Target user should be a moderator",
      );
      console.log("  - Moderator privilege granted successfully.");
      await userAuth.logout({ sessionToken: adminSession }); // Clean up
    });

    await t.step("fails if admin is not a moderator", async () => {
      console.log("\n--- Testing grantModerator: Non-Moderator Admin ---");
      const registerNonAdminResult = await userAuth.registerUser({
        username: "nonadmin",
        password: "pass",
      });
      if ("error" in registerNonAdminResult) {
        throw new Error(registerNonAdminResult.error);
      }
      const loginNonAdminResult = await userAuth.login({
        username: "nonadmin",
        password: "pass",
      });
      if ("error" in loginNonAdminResult) {
        throw new Error(loginNonAdminResult.error);
      }
      const nonAdminSession = loginNonAdminResult.sessionToken;
      console.log(`  Non-admin user setup (Session: ${nonAdminSession})`);

      const registerTargetResult = await userAuth.registerUser({
        username: "target2",
        password: "pass",
      });
      if ("error" in registerTargetResult) {
        throw new Error(registerTargetResult.error);
      }
      const targetUserId = registerTargetResult.userId;
      console.log(`  Target user registered (ID: ${targetUserId})`);

      const grantResult = await userAuth.grantModerator({
        targetUserId,
        adminSessionToken: nonAdminSession,
      });
      console.log("  grantModerator non-admin result:", grantResult);
      assertExists(
        (grantResult as { error: string }).error,
        "Error should be returned",
      );
      assertEquals(
        (grantResult as { error: string }).error,
        "Admin user does not have moderator privileges",
        "Error message should indicate non-moderator admin",
      );
      console.log(
        "  - Grant moderator by non-moderator admin correctly failed.",
      );
      await userAuth.logout({ sessionToken: nonAdminSession }); // Clean up
    });

    await t.step("fails for non-existent target user", async () => {
      console.log("\n--- Testing grantModerator: Non-existent Target User ---");
      const registerAdminResult = await userAuth.registerUser({
        username: "admin3",
        password: "adminpass",
      });
      if ("error" in registerAdminResult) {
        throw new Error(registerAdminResult.error);
      }
      const adminId = registerAdminResult.userId;
      await userAuth.users.updateOne({ _id: adminId }, {
        $set: { canModerate: true },
      }); // Bootstrap admin
      const loginAdminResult = await userAuth.login({
        username: "admin3",
        password: "adminpass",
      });
      if ("error" in loginAdminResult) throw new Error(loginAdminResult.error);
      const adminSession = loginAdminResult.sessionToken;
      console.log(
        `  Admin user setup (ID: ${adminId}, Session: ${adminSession})`,
      );

      const grantResult = await userAuth.grantModerator({
        targetUserId: "nonexistentuser" as ID,
        adminSessionToken: adminSession,
      });
      console.log("  grantModerator nonexistent target result:", grantResult);
      assertExists(
        (grantResult as { error: string }).error,
        "Error should be returned",
      );
      assertEquals(
        (grantResult as { error: string }).error,
        "Target user not found",
        "Error message should indicate target user not found",
      );
      console.log(
        "  - Grant moderator for non-existent target user correctly failed.",
      );
      await userAuth.logout({ sessionToken: adminSession }); // Clean up
    });
  });

  // --- revokeModerator Action Tests ---
  await t.step("revokeModerator", async (t) => {
    await t.step("successfully revokes moderator privilege", async () => {
      console.log("\n--- Testing revokeModerator: Success ---");
      const registerAdminResult = await userAuth.registerUser({
        username: "admin4",
        password: "adminpass",
      });
      if ("error" in registerAdminResult) {
        throw new Error(registerAdminResult.error);
      }
      const adminId = registerAdminResult.userId;
      await userAuth.users.updateOne({ _id: adminId }, {
        $set: { canModerate: true },
      }); // Bootstrap admin
      const loginAdminResult = await userAuth.login({
        username: "admin4",
        password: "adminpass",
      });
      if ("error" in loginAdminResult) throw new Error(loginAdminResult.error);
      const adminSession = loginAdminResult.sessionToken;
      console.log(
        `  Admin user setup (ID: ${adminId}, Session: ${adminSession})`,
      );

      const registerTargetResult = await userAuth.registerUser({
        username: "revoketarget",
        password: "targetpass",
      });
      if ("error" in registerTargetResult) {
        throw new Error(registerTargetResult.error);
      }
      const targetUserId = registerTargetResult.userId;
      console.log(`  Target user registered (ID: ${targetUserId})`);

      // First, grant moderator status
      await userAuth.grantModerator({
        targetUserId,
        adminSessionToken: adminSession,
      });
      const targetUserDetailsAfterGrant = await userAuth._getUserDetails({
        userId: targetUserId,
      });
      if ("error" in targetUserDetailsAfterGrant) {
        throw new Error(targetUserDetailsAfterGrant.error);
      }
      assertEquals(
        targetUserDetailsAfterGrant[0].user.canModerate,
        true,
        "Target user should be moderator after grant",
      );
      console.log("  - Target user granted moderator status.");

      // Then, revoke it
      const revokeResult = await userAuth.revokeModerator({
        targetUserId,
        adminSessionToken: adminSession,
      });
      console.log("  revokeModerator result:", revokeResult);
      if ("error" in revokeResult) {
        throw new Error(
          `Revoke moderator failed unexpectedly: ${revokeResult.error}`,
        );
      }
      assertEquals(
        revokeResult.success,
        true,
        "Revoke moderator should succeed",
      );

      const targetUserDetailsAfterRevoke = await userAuth._getUserDetails({
        userId: targetUserId,
      });
      if ("error" in targetUserDetailsAfterRevoke) {
        throw new Error(targetUserDetailsAfterRevoke.error);
      }
      assertEquals(
        targetUserDetailsAfterRevoke[0].user.canModerate,
        false,
        "Target user should not be a moderator after revoke",
      );
      console.log("  - Moderator privilege revoked successfully.");
      await userAuth.logout({ sessionToken: adminSession }); // Clean up
    });

    await t.step("fails if admin is not a moderator", async () => {
      console.log("\n--- Testing revokeModerator: Non-Moderator Admin ---");
      const registerNonAdminResult = await userAuth.registerUser({
        username: "nonadmin5",
        password: "pass",
      });
      if ("error" in registerNonAdminResult) {
        throw new Error(registerNonAdminResult.error);
      }
      const loginNonAdminResult = await userAuth.login({
        username: "nonadmin5",
        password: "pass",
      });
      if ("error" in loginNonAdminResult) {
        throw new Error(loginNonAdminResult.error);
      }
      const nonAdminSession = loginNonAdminResult.sessionToken;
      console.log(`  Non-admin user setup (Session: ${nonAdminSession})`);

      const registerTargetResult = await userAuth.registerUser({
        username: "target5",
        password: "pass",
      });
      if ("error" in registerTargetResult) {
        throw new Error(registerTargetResult.error);
      }
      const targetUserId = registerTargetResult.userId;
      await userAuth.users.updateOne({ _id: targetUserId }, {
        $set: { canModerate: true },
      }); // Make target moderator first for testing revoke
      console.log(
        `  Target user registered and made moderator (ID: ${targetUserId})`,
      );

      const revokeResult = await userAuth.revokeModerator({
        targetUserId,
        adminSessionToken: nonAdminSession,
      });
      console.log("  revokeModerator non-admin result:", revokeResult);
      assertExists(
        (revokeResult as { error: string }).error,
        "Error should be returned",
      );
      assertEquals(
        (revokeResult as { error: string }).error,
        "Admin user does not have moderator privileges",
        "Error message should indicate non-moderator admin",
      );
      console.log(
        "  - Revoke moderator by non-moderator admin correctly failed.",
      );
      await userAuth.logout({ sessionToken: nonAdminSession }); // Clean up
    });
  });

  // --- _getUserDetails Query Tests ---
  await t.step("_getUserDetails", async (t) => {
    await t.step("returns user details for existing user", async () => {
      console.log("\n--- Testing _getUserDetails: Existing User ---");
      const registerResult = await userAuth.registerUser({
        username: "queryuser",
        password: "querypass",
      });
      if ("error" in registerResult) throw new Error(registerResult.error);
      const userId = registerResult.userId;
      console.log(`  User 'queryuser' registered (ID: ${userId})`);

      const userDetailsResult = await userAuth._getUserDetails({ userId });
      console.log("  _getUserDetails result:", userDetailsResult);
      if ("error" in userDetailsResult) {
        throw new Error(userDetailsResult.error);
      }
      assertEquals(
        userDetailsResult.length,
        1,
        "Should return an array with one user",
      );
      assertObjectMatch(
        userDetailsResult[0].user,
        { username: "queryuser", canModerate: false },
        "User details should match",
      );
      console.log("  - User details retrieved successfully.");
    });

    await t.step("returns error for non-existent user", async () => {
      console.log("\n--- Testing _getUserDetails: Non-existent User ---");
      const userDetailsResult = await userAuth._getUserDetails({
        userId: "nonexistentuserquery" as ID,
      });
      console.log(
        "  _getUserDetails nonexistent user result:",
        userDetailsResult,
      );
      assertExists(
        (userDetailsResult as { error: string }).error,
        "Error should be returned",
      );
      assertEquals(
        (userDetailsResult as { error: string }).error,
        "User not found",
        "Error message should indicate user not found",
      );
      console.log("  - Query for non-existent user correctly returned error.");
    });
  });

  // --- _isModerator Query Tests ---
  await t.step("_isModerator", async (t) => {
    await t.step("returns correct status for moderator", async () => {
      console.log("\n--- Testing _isModerator: Moderator User ---");
      const registerResult = await userAuth.registerUser({
        username: "modquery",
        password: "pass",
      });
      if ("error" in registerResult) throw new Error(registerResult.error);
      const userId = registerResult.userId;
      await userAuth.users.updateOne({ _id: userId }, {
        $set: { canModerate: true },
      }); // Make moderator
      console.log(
        `  User 'modquery' registered and made moderator (ID: ${userId})`,
      );

      const isModResult = await userAuth._isModerator({ userId });
      console.log("  _isModerator moderator result:", isModResult);
      if ("error" in isModResult) throw new Error(isModResult.error);
      assertEquals(
        isModResult.length,
        1,
        "Should return an array with one result",
      );
      assertEquals(
        isModResult[0].isModerator,
        true,
        "Should return true for moderator",
      );
      console.log(
        "  - Moderator status for moderator user retrieved correctly.",
      );
    });

    await t.step("returns correct status for non-moderator", async () => {
      console.log("\n--- Testing _isModerator: Non-Moderator User ---");
      const registerResult = await userAuth.registerUser({
        username: "nonmodquery",
        password: "pass",
      });
      if ("error" in registerResult) throw new Error(registerResult.error);
      const userId = registerResult.userId;
      console.log(`  User 'nonmodquery' registered (ID: ${userId})`);

      const isModResult = await userAuth._isModerator({ userId });
      console.log("  _isModerator non-moderator result:", isModResult);
      if ("error" in isModResult) throw new Error(isModResult.error);
      assertEquals(
        isModResult.length,
        1,
        "Should return an array with one result",
      );
      assertEquals(
        isModResult[0].isModerator,
        false,
        "Should return false for non-moderator",
      );
      console.log(
        "  - Moderator status for non-moderator user retrieved correctly.",
      );
    });

    await t.step("returns error for non-existent user", async () => {
      console.log("\n--- Testing _isModerator: Non-existent User ---");
      const isModResult = await userAuth._isModerator({
        userId: "nonexistentmodquery" as ID,
      });
      console.log("  _isModerator nonexistent user result:", isModResult);
      assertExists(
        (isModResult as { error: string }).error,
        "Error should be returned",
      );
      assertEquals(
        (isModResult as { error: string }).error,
        "User not found",
        "Error message should indicate user not found",
      );
      console.log("  - Query for non-existent user correctly returned error.");
    });
  });
});

```
