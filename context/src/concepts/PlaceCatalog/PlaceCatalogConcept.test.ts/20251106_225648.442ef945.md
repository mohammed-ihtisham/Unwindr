---
timestamp: 'Thu Nov 06 2025 22:56:48 GMT-0500 (Eastern Standard Time)'
content_id: 442ef9459448cd98c40cf13f40cc5ba1572e6db74f076ac10b72e82712d42f72
---

# file: src/concepts/PlaceCatalog/PlaceCatalogConcept.test.ts

```typescript
import {
  assertArrayIncludes,
  assertEquals,
  assertExists,
} from "jsr:@std/assert";
import { testDb } from "@utils/database.ts";
import { freshID } from "@utils/database.ts";
import PlaceCatalogConcept from "./PlaceCatalogConcept.ts";
import { ID } from "@utils/types.ts";

// Helper for checking if a result is an error
const isError = (result: unknown): result is { error: string } =>
  result !== null && typeof result === "object" && "error" in result;

/**
 * Helper to create test places using the concept action.
 * This follows the "no state setup" guideline by using concept actions.
 */
async function createTestPlace(
  placeCatalog: PlaceCatalogConcept,
  name: string,
  address: string,
  category: string,
  lat: number,
  lng: number,
): Promise<ID> {
  const result = await placeCatalog.addPlace({
    userId: "system:test" as ID,
    name,
    address,
    category,
    lat,
    lng,
  });
  if (isError(result)) {
    throw new Error(`Failed to create test place: ${result.error}`);
  }
  return result.placeId;
}

// Operational Principle: Users discover places in a viewport, then retrieve full details
Deno.test("Principle: Places can be discovered and retrieved", async (t) => {
  console.log(
    "\n=== Principle Test: Places can be discovered and retrieved ===",
  );
  const [db, client] = await testDb();
  const placeCatalog = new PlaceCatalogConcept(db);

  try {
    // Setup test place (exception: query-only concept needs DB setup)
    const testPlaceId = await createTestPlace(
      placeCatalog,
      "Boston Public Garden",
      "4 Charles Street, Boston, MA",
      "park",
      42.35,
      -71.07,
    );
    console.log(`[SETUP] Created test place: ${testPlaceId}`);

    await t.step("1. Discover places in viewport", async () => {
      console.log("\n[QUERY] Discovering places in Boston area");
      const viewportResult = await placeCatalog.getPlacesInViewport({
        southLat: 42.34,
        westLng: -71.08,
        northLat: 42.36,
        eastLng: -71.06,
      });
      console.log("  Output:", viewportResult);
      assertEquals(
        isError(viewportResult),
        false,
        "Viewport query should succeed",
      );
      const places = viewportResult as Array<{ id: ID; name: string }>;
      assertExists(places.length > 0, "Should find at least one place");
      const foundPlace = places.find((p) => p.id === testPlaceId);
      assertExists(foundPlace, "Should find the test place");
      assertEquals(foundPlace.name, "Boston Public Garden");
      console.log(`  ✓ Found ${places.length} place(s) in viewport`);
    });

    await t.step("2. Retrieve full place details", async () => {
      console.log("\n[QUERY] Retrieving full details for discovered place");
      const detailsResult = await placeCatalog._getPlaceDetails({
        placeId: testPlaceId,
      });
      console.log("  Output:", detailsResult);
      assertEquals(
        isError(detailsResult),
        false,
        "Details query should succeed",
      );
      const { place } = detailsResult as {
        place: { id: ID; name: string; address: string };
      };
      assertEquals(place.id, testPlaceId);
      assertEquals(place.name, "Boston Public Garden");
      assertEquals(place.address, "4 Charles Street, Boston, MA");
      console.log("  ✓ Retrieved full place details");
    });

    console.log(
      "\n✅ Principle demonstrated: Users discover places, then retrieve details",
    );
  } finally {
    await client.close();
  }
});

// Scenario 1: Empty viewport returns empty array
Deno.test("Scenario: Empty viewport returns no places", async () => {
  console.log("\n=== Scenario: Empty viewport ===");
  const [db, client] = await testDb();
  const placeCatalog = new PlaceCatalogConcept(db);

  try {
    // Setup: Create a place far from the query area
    await createTestPlace(
      placeCatalog,
      "Distant Place",
      "Far Away",
      "test",
      40.0,
      -73.0,
    );
    console.log("[SETUP] Created distant place");

    console.log("\n[QUERY] Query empty area (no places nearby)");
    const result = await placeCatalog.getPlacesInViewport({
      southLat: 42.0,
      westLng: -71.5,
      northLat: 42.1,
      eastLng: -71.4,
    });
    console.log("  Output:", result);
    assertEquals(isError(result), false, "Query should succeed");
    const places = result as Array<unknown>;
    assertEquals(
      places.length,
      0,
      "Should return empty array for area with no places",
    );
    console.log("  ✓ Empty viewport correctly returns empty array");
  } finally {
    await client.close();
  }
});

// Scenario 2: Non-existent place returns error
Deno.test("Scenario: Querying non-existent place returns error", async () => {
  console.log("\n=== Scenario: Non-existent place ===");
  const [db, client] = await testDb();
  const placeCatalog = new PlaceCatalogConcept(db);

  try {
    const nonExistentId = freshID();
    console.log(`\n[QUERY] Query non-existent place: ${nonExistentId}`);
    const result = await placeCatalog._getPlaceDetails({
      placeId: nonExistentId,
    });
    console.log("  Output:", result);
    assertEquals(isError(result), true, "Should return error");
    assertEquals(
      (result as { error: string }).error,
      `Place with ID ${nonExistentId} not found.`,
      "Error message should indicate place not found",
    );
    console.log("  ✓ Correctly returned error for non-existent place");
  } finally {
    await client.close();
  }
});

// Scenario 3: Invalid viewport bounds are rejected
Deno.test("Scenario: Invalid viewport bounds rejected", async () => {
  console.log("\n=== Scenario: Invalid viewport bounds ===");
  const [db, client] = await testDb();
  const placeCatalog = new PlaceCatalogConcept(db);

  try {
    console.log("\n[QUERY] Invalid viewport (south >= north)");
    const result1 = await placeCatalog.getPlacesInViewport({
      southLat: 42.5,
      westLng: -71.1,
      northLat: 42.4, // Invalid: north is less than south
      eastLng: -71.0,
    });
    console.log("  Output:", result1);
    assertEquals(isError(result1), true, "Should reject invalid bounds");
    assertEquals(
      (result1 as { error: string }).error,
      "Invalid viewport bounds.",
    );
    console.log("  ✓ Rejected viewport with south >= north");

    console.log("\n[QUERY] Invalid coordinates (lat > 90)");
    const result2 = await placeCatalog.getPlacesInViewport({
      southLat: 91, // Invalid: exceeds valid latitude range
      westLng: -71.1,
      northLat: 92,
      eastLng: -71.0,
    });
    console.log("  Output:", result2);
    assertEquals(isError(result2), true, "Should reject invalid coordinates");
    assertEquals(
      (result2 as { error: string }).error,
      "Invalid coordinates provided.",
    );
    console.log("  ✓ Rejected viewport with invalid coordinates");

    console.log("\n[QUERY] Empty placeId");
    const result3 = await placeCatalog._getPlaceDetails({
      placeId: "" as ID,
    });
    console.log("  Output:", result3);
    assertEquals(isError(result3), true, "Should reject empty placeId");
    assertEquals(
      (result3 as { error: string }).error,
      "Place ID is required.",
    );
    console.log("  ✓ Rejected empty placeId");
  } finally {
    await client.close();
  }
});

// Scenario 4: Multiple places in viewport are all returned
Deno.test("Scenario: Multiple places in viewport", async () => {
  console.log("\n=== Scenario: Multiple places in viewport ===");
  const [db, client] = await testDb();
  const placeCatalog = new PlaceCatalogConcept(db);

  try {
    // Setup: Create multiple places in the same area
    const place1Id = await createTestPlace(
      placeCatalog,
      "Central Park",
      "1 Central Park, Boston",
      "park",
      42.36,
      -71.07,
    );
    const place2Id = await createTestPlace(
      placeCatalog,
      "City Library",
      "2 Main St, Boston",
      "library",
      42.37,
      -71.08,
    );
    const place3Id = await createTestPlace(
      placeCatalog,
      "Coffee Shop",
      "3 Oak Ave, Boston",
      "cafe",
      42.355,
      -71.075,
    );
    console.log(
      `[SETUP] Created 3 places: ${place1Id}, ${place2Id}, ${place3Id}`,
    );

    console.log("\n[QUERY] Query viewport containing multiple places");
    const result = await placeCatalog.getPlacesInViewport({
      southLat: 42.35,
      westLng: -71.09,
      northLat: 42.38,
      eastLng: -71.06,
    });
    console.log("  Output:", result);
    assertEquals(isError(result), false, "Query should succeed");
    const places = result as Array<{ id: ID; name: string }>;
    assertEquals(places.length, 3, "Should find all 3 places");
    const placeIds = places.map((p) => p.id);
    assertArrayIncludes(placeIds, [place1Id, place2Id, place3Id]);
    console.log(`  ✓ Found all ${places.length} places in viewport`);

    // Verify structure of returned places
    places.forEach((place) => {
      assertExists(place.id, "Place should have id");
      assertExists(place.name, "Place should have name");
      assertExists("category" in place, "Place should have category");
      assertExists("lat" in place, "Place should have lat");
      assertExists("lng" in place, "Place should have lng");
    });
    console.log("  ✓ All places have correct structure");
  } finally {
    await client.close();
  }
});

// Scenario 5: Querying the same place multiple times (idempotency)
Deno.test("Scenario: Repeated queries return consistent results", async () => {
  console.log("\n=== Scenario: Repeated queries ===");
  const [db, client] = await testDb();
  const placeCatalog = new PlaceCatalogConcept(db);

  try {
    // Setup: Create a test place
    const placeId = await createTestPlace(
      placeCatalog,
      "Consistent Place",
      "123 Test St",
      "test",
      42.35,
      -71.07,
    );
    console.log(`[SETUP] Created test place: ${placeId}`);

    console.log("\n[QUERY] Query same place multiple times");
    const result1 = await placeCatalog._getPlaceDetails({ placeId });
    const result2 = await placeCatalog._getPlaceDetails({ placeId });
    const result3 = await placeCatalog._getPlaceDetails({ placeId });

    console.log("  First query:", result1);
    console.log("  Second query:", result2);
    console.log("  Third query:", result3);

    assertEquals(isError(result1), false, "First query should succeed");
    assertEquals(isError(result2), false, "Second query should succeed");
    assertEquals(isError(result3), false, "Third query should succeed");

    const place1 = (result1 as { place: { name: string } }).place;
    const place2 = (result2 as { place: { name: string } }).place;
    const place3 = (result3 as { place: { name: string } }).place;

    assertEquals(place1.name, place2.name, "Results should be consistent");
    assertEquals(place2.name, place3.name, "Results should be consistent");
    assertEquals(place1.name, "Consistent Place");
    console.log("  ✓ All queries return consistent results");
  } finally {
    await client.close();
  }
});

```
