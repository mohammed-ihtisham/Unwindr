---
timestamp: 'Thu Nov 06 2025 22:56:42 GMT-0500 (Eastern Standard Time)'
content_id: a5644e53171be270021ce7cad775b2da4fdd54ca3a2c20092dcb372fa178ae4c
---

# file: src/concepts/PlaceCatalog/PlaceCatalogConcept.ts

```typescript
import { Collection, Db } from "npm:mongodb";
import { ID } from "@utils/types.ts";
import { freshID } from "@utils/database.ts";

// Declare collection prefix, use concept name
const PREFIX = "PlaceCatalog" + ".";

// Generic types of this concept (kept for type compatibility with PlaceDocument)
type User = ID;

/**
 * a set of Locations with
 *   a latitude Number
 *   a longitude Number
 *
 * This will be embedded within a Place document for geospatial indexing.
 * MongoDB GeoJSON Point format is [longitude, latitude].
 */
interface LocationData {
  type: "Point";
  coordinates: [number, number]; // [longitude, latitude]
}

/**
 * a set of Places with
 *   an _id Id
 *   a name String
 *   an address String
 *   a category String
 *   a verified Flag
 *   an addedBy User
 *   a location Location
 *   a source String // "provider" or "user_added"
 *   tags (optional) Array of String
 *   Optional enrichment fields: editorialSummary, googleRating, googleReviewCount, imagesUrl
 */
interface PlaceDocument {
  _id: ID;
  name: string;
  address: string;
  category: string;
  verified: boolean;
  addedBy: User;
  location: LocationData;
  source: "provider" | "user_added";
  tags?: string[]; // Optional tags for place filtering
  // Optional enrichment fields from external APIs (e.g., Google Places)
  editorialSummary?: string; // Brief overview
  googleRating?: number; // User rating (1-5)
  googleReviewCount?: number; // Total number of ratings
  imagesUrl?: string; // Link to Google Images search for this place
}

// Helper for coordinate validation
function isValidCoordinates(lat: number, lng: number): boolean {
  return lat >= -90 && lat <= 90 && lng >= -180 && lng <= 180;
}

export default class PlaceCatalogConcept {
  places: Collection<PlaceDocument>;

  constructor(private readonly db: Db) {
    this.places = this.db.collection(PREFIX + "places");
    // Ensure 2dsphere index for geospatial queries
    this.places.createIndex({ "location": "2dsphere" }).catch(() => {});
  }

  /**
   * addPlace (userId: Id, name: String, address: String, category: String, lat: Number, lng: Number): (placeId: Id) | {error: string}
   *
   * **Note**: This method is kept for MVP seeding/testing purposes only. Not exposed to end users.
   *
   * **requires** name is not empty and coordinates are valid
   * **effects** creates a new place and returns its ID.
   */
  async addPlace(
    { userId, name, address, category, lat, lng }: {
      userId: User;
      name: string;
      address: string;
      category: string;
      lat: number;
      lng: number;
    },
  ): Promise<{ placeId: ID } | { error: string }> {
    if (!name || name.trim() === "") {
      return { error: "Place name cannot be empty." };
    }
    if (!isValidCoordinates(lat, lng)) {
      return { error: "Invalid coordinates." };
    }

    const newPlace: PlaceDocument = {
      _id: freshID(),
      name: name.trim(),
      address: address.trim(),
      category: category.trim(),
      verified: false,
      addedBy: userId,
      location: {
        type: "Point",
        coordinates: [lng, lat],
      },
      source: "user_added",
    };

    try {
      await this.places.insertOne(newPlace);
      return { placeId: newPlace._id };
    } catch (e) {
      return {
        error: `Failed to add place: ${
          e instanceof Error ? e.message : String(e)
        }`,
      };
    }
  }

  /**
   * _getPlaceDetails (placeId: Id): (place: {name: String, address: String, ...}) | {error: string}
   *
   * This is an additional query to retrieve full details of a single place,
   * often useful for display after getting an ID from a list.
   *
   * **requires** place exists
   * **effects** returns the full details of the specified place.
   */
  async _getPlaceDetails(
    { placeId }: { placeId: ID },
  ): Promise<
    { place: Omit<PlaceDocument, "_id"> & { id: ID } } | { error: string }
  > {
    if (!placeId) {
      return { error: "Place ID is required." };
    }

    const place = await this.places.findOne({ _id: placeId });

    if (!place) {
      return { error: `Place with ID ${placeId} not found.` };
    }

    // Return the document without _id and with id as per common API patterns
    const { _id, ...rest } = place;
    return { place: { id: _id, ...rest } };
  }

  /**
   * getPlacesInViewport (southLat: Number, westLng: Number, northLat: Number, eastLng: Number): (places: Array<PlaceData>) | {error: string}
   *
   * **requires** coordinates are valid, forming a proper viewport rectangle
   *
   * **effects** returns places within the viewport with essential data for map display.
   *             Optimized for lazy loading - returns only fields needed for map markers.
   */
  async getPlacesInViewport(
    { southLat, westLng, northLat, eastLng }: {
      southLat: number;
      westLng: number;
      northLat: number;
      eastLng: number;
    },
  ): Promise<
    Array<{
      id: ID;
      name: string;
      category: string;
      lat: number;
      lng: number;
    }> | { error: string }
  > {
    if (
      !isValidCoordinates(southLat, westLng) ||
      !isValidCoordinates(northLat, eastLng)
    ) {
      return { error: "Invalid coordinates provided." };
    }
    if (southLat >= northLat || westLng >= eastLng) {
      return { error: "Invalid viewport bounds." };
    }

    try {
      const foundPlaces = await this.places.find({
        location: {
          $geoWithin: {
            $box: [
              [westLng, southLat], // Southwest corner [lng, lat]
              [eastLng, northLat], // Northeast corner [lng, lat]
            ],
          },
        },
      }, {
        projection: {
          _id: 1,
          name: 1,
          category: 1,
          location: 1,
        },
      }).toArray();

      // Transform to include lat/lng as separate fields for easier frontend consumption
      return foundPlaces.map((p) => ({
        id: p._id,
        name: p.name,
        category: p.category,
        lat: p.location.coordinates[1],
        lng: p.location.coordinates[0],
      }));
    } catch (e) {
      return {
        error: `Failed to retrieve places in viewport: ${
          e instanceof Error ? e.message : String(e)
        }`,
      };
    }
  }
}

```
